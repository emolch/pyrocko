#!/usr/bin/env python

import sys, re, os, logging, copy, math, collections
from optparse import OptionParser
import numpy as num
from scipy import spatial

import yaml

from pyrocko import util, trace, gf, cake, spit

pjoin = os.path.join

logger = logging.getLogger('main')


def d2u(d):
    return dict((k.replace('-','_'), v) for (k,v) in d.iteritems())

subcommand_descriptions = {
        'init':          'create a new empty GF store',
        'build':         'compute GFs and fill into store',
        'stats':         'print information about a GF store',
        'check':         'check for problems in GF store',
        'decimate':      'build decimated variant of a GF store',
        'redeploy':      'copy traces from one GF store into another',
        'view':          'view selected traces',
        'import':        'convert Kiwi GFDB to GF store format',
        'ttt':           'create travel time tables',
        'tttview':       'plot travel time table',
    }

subcommand_usages = {
        'init':          ['init <type> <store-dir> [options]',
                         'init redeploy <source> <destination> [options]'],
        'build':         'build [store-dir] [options]',
        'stats':         'stats [store-dir] [options]',
        'check':         'check [store-dir] [options]',
        'decimate':      'decimate [store-dir] <factor> [options]',
        'redeploy':      'redeploy <source> <destination> [options]',
        'view':          'view [store-dir] ... [options]',
        'import':        'import <source> <destination> [options]',
        'ttt':           'ttt [store-dir] [options]',
        'tttview':       'tttview [store-dir] <phase-id>',
    }

subcommands = subcommand_descriptions.keys()

program_name = 'fomosto'

usage = program_name + ''' <subcommand> <arguments> ... [options] 

Subcommands:

    init          %(init)s
    build         %(build)s
    stats         %(stats)s
    check         %(check)s
    decimate      %(decimate)s
    redeploy      %(redeploy)s
    view          %(view)s
    import        %(import)s
    ttt           %(ttt)s
    tttview       %(tttview)s

To get further help and a list of available options for any subcommand run:

    fomosto <subcommand> --help

''' % d2u(subcommand_descriptions)

def add_common_options(parser):
    parser.add_option('--loglevel', 
        action = 'store', 
        dest = 'loglevel', 
        type = 'choice',
        choices = ('error', 'warning', 'info', 'debug'), 
        default = 'info',
        help ='set logger level to "error", "warning", "info", or "debug". '
              'Default is "%default".')

def process_common_options(options):
    util.setup_logging(program_name, options.loglevel)

def cl_parse(command, args, setup=None):
    usage = subcommand_usages[command]
    descr = subcommand_descriptions[command]

    if isinstance(usage, basestring):
        usage = [ usage ]

    susage = '%s %s' % (program_name, usage[0])
    for s in usage[1:]:
        susage += '\n%s%s %s' % (' '*7, program_name, s)
        
    parser = OptionParser(usage=susage,
            description=descr[0].upper() + descr[1:] + '.' )

    if setup:
        setup(parser)

    add_common_options(parser)
    (options, args) = parser.parse_args(args)
    process_common_options(options)
    return parser, options, args

def die(message):
    sys.exit('%s: error: %s' % (program_name, message))

def fomo_wrapper_module(name):
    try:
        if not re.match(gf.meta.StringID.pattern, name):
            raise ValueError('invalid name')

        name_clean = re.sub(r'[.-]', '_', name)
        modname = '.'.join(['pyrocko', 'fomosto', name_clean])
        mod = __import__(modname, level=0)
        return getattr(mod.fomosto, name_clean)

    except ValueError:
        die('invalid modelling code wrapper name')

    except ImportError:
        die('''modelling code wrapper "%s" not available or not installed
                (module probed: "%s")''' % (name, modname))

def command_init(args):

    parser, options, args = cl_parse('init', args)

    if len(args) == 0:
        parser.print_help()
        sys.exit(1)
    
    if args[0] == 'redeploy':
        if len(args) != 3:
            parser.error('incorrect number of arguments')

        source_dir, dest_dir = args[1:]

        try:
            source = gf.Store(source_dir)
        except gf.StoreError, e:
            die(e)

            
        config = copy.deepcopy(source.config)
        config.derived_from_id = source.config.id
        config.id = 'derived_from_' + config.id
        try:
            config_filenames = gf.store.Store.create_editables(dest_dir, config=config)
        except gf.StoreError, e:
            die(e)
        
        logger.info('(1) configure settings in files:\n  %s' % '\n  '.join(config_filenames))
        logger.info('(2) run "fomosto redeploy <source> <dest>", as needed')

    else:
        if len(args) != 2:
            parser.error('incorrect number of arguments')

        (modelling_code_id, store_dir) = args

        module = fomo_wrapper_module(modelling_code_id)
        try:
            config_filenames = module.init(store_dir)
        except gf.StoreError, e:
            die(e)

        logger.info('(1) configure settings in files:\n  %s' % '\n  '.join(config_filenames))
        logger.info('(2) run "fomosto ttt" in directory "%s"' % store_dir)
        logger.info('(3) run "fomosto build" in directory "%s"' % store_dir)

def get_store_dir(args):
    if len(args) == 1:
        store_dir = os.path.abspath(args.pop(0))
    else:
        store_dir = os.path.abspath(os.path.curdir) 

    if not os.path.isdir(store_dir):
        die('not a directory: %s' % store_dir)

    return store_dir

def get_store_dirs(args):
    if len(args) == 0:
        store_dirs = [ os.path.abspath(os.path.curdir) ]
    else:
        store_dirs = [ os.path.abspath(x) for x in args ]

    for store_dir in store_dirs:
        if not os.path.isdir(store_dir):
            die('not a directory: %s' % store_dir)

    return store_dirs

def command_build(args):

    def setup(parser):
        parser.add_option('--force', dest='force', action='store_true',
                help='overwrite existing files')

        parser.add_option('--nworkers', dest='nworkers', type='int', metavar='N',
                help='run N worker processes in parallel')

    parser, options, args = cl_parse('build', args, setup=setup)

    store_dir = get_store_dir(args)
    try:
        store = gf.Store(store_dir)
        module = fomo_wrapper_module(store.config.modelling_code_id)
        module.build(store_dir, 
                force=options.force, 
                nworkers=options.nworkers)

    except gf.StoreError, e:
        die(e)

def command_stats(args):

    parser, options, args = cl_parse('stats', args)
    store_dir = get_store_dir(args)

    try:
        store = gf.Store(store_dir)
        s = store.stats()

    except gf.StoreError, e:
        die(e)

    for k in store.stats_keys:
        print '%s: %s' % (k, s[k])


def command_check(args):

    parser, options, args = cl_parse('check', args)
    store_dir = get_store_dir(args)

    try:
        store = gf.Store(store_dir)
        problems = store.check()
        if problems:
            die('problems detected with gf store: %s' % store_dir)

    except gf.StoreError, e:
        die(e)

def load_config(fn):
    try:
        config = gf.meta.load(filename=fn)
        assert isinstance(config, gf.Config)

    except:
        die('cannot load gf config from file: %s' % fn)

    return config

def command_decimate(args):

    def setup(parser):
        parser.add_option('--config', dest='config_fn', metavar='FILE',
                help='use modified spacial sampling given in FILE')

        parser.add_option('--force', dest='force', action='store_true',
                help='overwrite existing files')

    parser, options, args = cl_parse('decimate', args, setup=setup)
    try:
        decimate = int(args.pop())
    except:
        parser.error('cannot get <factor> argument')

    store_dir = get_store_dir(args)

    config = None
    if options.config_fn:
        config = load_config(options.config_fn)

    try:
        store = gf.Store(store_dir)
        store.make_decimated(decimate, config=config, force=options.force)

    except gf.StoreError, e:
        die(e)

def sindex(args):
    return str(tuple(x.tolist() for x in args))

def command_redeploy(args):

    parser, options, args = cl_parse('redeploy', args)

    if not len(args) == 2:
        parser.print_help()
        sys.exit(1)

    source_store_dir, dest_store_dir = args

    try:
        source = gf.Store(source_store_dir)
    except gf.StoreError, e:
        die(e)

    try:
        gf.store.Store.create_dependants(dest_store_dir)
    except gf.StoreError:
        pass

    try:
        dest = gf.Store(dest_store_dir, 'w')

    except gf.StoreError, e:
        die(e)

    for args in dest.config.iter_nodes():
        try:
            tr = source.get(args, interpolate='off')
            dest.put(args, tr)

        except (gf.meta.OutOfBounds, gf.store.NotAllowedToInterpolate), e:
            logger.debug('skipping %s, (%s)' % (sindex(args), e))

        except gf.store.StoreError, e:
            logger.warn('cannot insert %s, (%s)' % (sindex(args), e))

def command_view(args):
    def setup(parser):
        parser.add_option('--extract', dest='extract', metavar='start:stop[:step|@num],...',
                help='specify which traces to show')

    parser, options, args = cl_parse('view', args, setup=setup)
    
    gdef = None
    if options.extract:
        try:
            gdef = gf.meta.parse_grid_spec(options.extract)
        except gf.meta.GridSpecError, e:
            die(e)

    store_dirs = get_store_dirs(args)

    alpha = 'abcdefghijklmnopqrstxyz'.upper()

    traces = []

    try:
        for istore, store_dir in enumerate(store_dirs):
            store = gf.Store(store_dir)
            ii = 0
            for args in store.config.iter_extraction(gdef):
                gtr = store.get(args)

                loc_code = ''
                if len(store_dirs) > 1:
                    loc_code = alpha[istore%len(alpha)]
                
                if gtr:
                    
                    sta_code = '%04i (%s)' % (ii, ','.join('%gk' % (x/1000.) for x in args[:-1]))

                    tr = trace.Trace(
                            '',
                            sta_code,
                            loc_code,
                            '%02i' % args[-1],
                            ydata = gtr.data,
                            deltat = gtr.deltat,
                            tmin = gtr.deltat * gtr.itmin)

                    traces.append(tr)

                ii += 1 
                
    except (gf.meta.GridSpecError, gf.StoreError, gf.meta.OutOfBounds), e:
        die(e)

    trace.snuffle(traces)

def command_import(args):
    try:
        from tunguska import gfdb
    except ImportError:
        die('the kiwi tools must be installed to use this feature')

    parser, options, args = cl_parse('import', args)

    if not len(args) == 2:
        parser.print_help()
        sys.exit(1)

    source_path, dest_store_dir = args

    if os.path.isdir(source_path):
        source_path = pjoin(source_path, 'db')
    
    source_path = re.sub(r'(\.\d+\.chunk|\.index)$', '', source_path)
        
    db = gfdb.Gfdb(source_path)

    config = gf.meta.ConfigTypeA(
            id = 'imported-gfs',
            distance_min = db.firstx,
            distance_max = db.firstx + (db.nx-1) * db.dx,
            distance_delta = db.dx,
            source_depth_min = db.firstz,
            source_depth_max = db.firstz + (db.nz-1) * db.dz,
            source_depth_delta = db.dz,
            sample_rate = 1.0/db.dt,
            ncomponents = db.ng
        )

    try:
        gf.store.Store.create(dest_store_dir, config=config)
        dest = gf.Store(dest_store_dir, 'w')
        for args in dest.config.iter_nodes(level=-1):
            source_depth, distance = [ float(x) for x in args ]
            traces = db.get_traces_pyrocko(distance, source_depth)
            for tr in traces:
                gf_tr = gf.store.GFTrace(tr.get_ydata(),
                        int(round(tr.tmin / tr.deltat)), tr.deltat)

                dest.put((source_depth, distance, tr.meta['ig']-1), gf_tr)

        dest.close()

    except gf.StoreError, e:
        die(e)

def phasedef_or_horvel(x):
    try:
        return float(x)
    except ValueError:
        return cake.PhaseDef(x)

def mkp(s):
    return [ phasedef_or_horvel(ps) for ps in s.split(',') ]

km = 1000.

def command_ttt(args):
    def setup(parser):
        parser.add_option('--force', dest='force', action='store_true',
                help='overwrite existing files')

    parser, options, args = cl_parse('ttt', args, setup=setup)

    store_dir = get_store_dir(args)
    try:
        store = gf.Store(store_dir)
        config = store.config
        
        mod = config.earthmodel_1d
        if not mod:
            die('no earth model found')

        for pdef in config.tabulated_phases:

            phase_id = pdef.id
            phases = pdef.phases
            horvels = pdef.horizontal_velocities

            fn = pjoin( store_dir, 'phases', '%s.phase' % phase_id)

            if os.path.exists(fn) and not options.force:
                logger.info('file already exists: %s' % fn)
                continue

            def evaluate(args):

                if len(args) == 2:
                    zr, zs, x = (config.receiver_depth,) + args
                elif len(args) == 3:
                    zr, zs, x = args
                else:
                    assert False

                t = []
                if phases:
                    rays = mod.arrivals(
                            phases = phases,
                            distances = [ x*cake.m2d ],
                            zstart = zs,
                            zstop = zr)

                    for ray in rays:
                        t.append(ray.t)

                for v in pdef.horizontal_velocities:
                    t.append(x/(v*1000.))
                
                if t:
                    return min(t)
                else:
                    return None

            logger.info('making travel time table for phasegroup "%s"' % phase_id)
            ip = spit.SPTree(
                f = evaluate,
                ftol = config.deltat*0.5,
                xbounds = num.transpose((config.mins, config.maxs)),
                xtols = config.deltas)

            util.ensuredirs(fn)
            ip.dump(fn)
            
    except gf.StoreError, e:
        die(e)

def command_tttview(args):

    parser, options, args = cl_parse('tttview', args)
    
    try:
        phase_id = args.pop()
    except:
        parser.error('cannot get <phase-id> argument')

    store_dir = get_store_dir(args)

    try:
        store = gf.Store(store_dir)
        phase = store.get_phase(phase_id)
        phase.plot_2d()

    except gf.StoreError, e:
        die(e)

if __name__ == '__main__':

    usage_sub = 'fomosto %s [options]'
    if len(sys.argv) < 2:
        sys.exit('Usage: %s' % usage)

    args = list(sys.argv)
    args.pop(0)
    command = args.pop(0)

    if command in subcommands:
        globals()['command_'+ command](args)

    elif command in ('--help', '-h', 'help'):
        if command == 'help' and args:
            acommand = args[0]
            if acommand in subcommands:
                globals()['command_'+ acommand]([ '--help' ] )
            
        sys.exit('Usage: %s' % usage)

    else:
        sys.exit('fomosto: error: no such subcommand: %s' % command)

